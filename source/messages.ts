import { mkdir, writeFile } from "node:fs/promises";
import { join } from "node:path";
import type {
  CoreAssistantMessage,
  CoreMessage,
  CoreToolMessage,
  CoreUserMessage,
} from "ai";

export function createUserMessage(content: string): CoreUserMessage {
  return {
    role: "user",
    content: [
      {
        type: "text",
        text: content,
      },
    ],
  };
}

export function createAssistantMessage(content: string): CoreAssistantMessage {
  return {
    role: "assistant",
    content: [
      {
        type: "text",
        text: content,
      },
    ],
  };
}

/**
A message that was generated during the generation process.
It can be either an assistant message or a tool message.
 */
type ResponseMessage = (CoreAssistantMessage | CoreToolMessage) & {
  /**
Message ID generated by the AI SDK.
 */
  id: string;
};

export class MessageHistory {
  private history: CoreMessage[];
  private stateDir: string;
  constructor({ stateDir }: { stateDir: string }) {
    this.history = [];
    this.stateDir = stateDir;
  }

  get() {
    return [...this.history];
  }

  clear() {
    this.history.length = 0;
  }

  appendUserMessage(user: CoreUserMessage) {
    this.history.push(user);
  }

  appendAssistantMessage(assistant: CoreAssistantMessage) {
    this.history.push(assistant);
  }

  appendResponseMessages(responseMessages: ResponseMessage[]) {
    this.history.push(...responseMessages);
  }

  isEmpty() {
    return this.history.length === 0;
  }

  async save() {
    await mkdir(this.stateDir, { recursive: true });
    const timestamp = new Date().toISOString().replace(/:/g, "-");
    const fileName = `message-history-${timestamp}.json`;
    const filePath = join(this.stateDir, fileName);

    await writeFile(filePath, JSON.stringify(this.history, null, 2));
  }
}

/**
 * Normalizes an array of messages for API consumption by:
 * 1. Filtering out progress-type messages
 * 2. Processing user and assistant messages
 * 3. Handling tool results by either:
 *    - Adding them as new messages if they're the first tool result
 *    - Adding them as new messages if the previous message wasn't a tool result
 *    - Merging them with the previous message if it was also a tool result
 *
 * This consolidation of sequential tool results into a single message
 * ensures proper formatting for API consumption while maintaining the
 * logical flow of the conversation.
 *
 * @param messages - Array of messages to normalize
 * @returns Normalized array of user and assistant messages ready for API
 */
export function normalizeMessagesForApi(
  messages: CoreMessage[],
): CoreMessage[] {
  const result: CoreMessage[] = [];
  for (const message of messages) {
    switch (message.role) {
      case "user": {
        result.push(message);
        continue;
      }
      case "tool": {
        // If the last message is not a tool result, add it to the result
        const lastMessage = result.at(-1);
        if (
          !lastMessage ||
          lastMessage.role === "assistant" ||
          !Array.isArray(lastMessage.content) ||
          lastMessage.content[0]?.type !== "tool-result"
        ) {
          result.push(message);
          continue;
        }

        // Otherwise, merge the current message with the last message
        result[result.indexOf(lastMessage)] = {
          ...lastMessage,
          content: [...lastMessage.content, ...message.content] as any,
        };
        continue;
      }
      case "assistant": {
        result.push(message);
        continue;
      }
      default:
        continue;
    }
  }
  return result;
}
