import { mkdir, writeFile } from "node:fs/promises";
import { join } from "node:path";
import { isString } from "@travisennis/stdlib/typeguards";
import {
  type CoreAssistantMessage,
  type CoreMessage,
  type CoreToolMessage,
  type CoreUserMessage,
  type LanguageModel,
  generateText,
} from "ai";

export function createUserMessage(content: string): CoreUserMessage {
  return {
    role: "user",
    content: [
      {
        type: "text",
        text: content,
      },
    ],
  };
}

export function createAssistantMessage(content: string): CoreAssistantMessage {
  return {
    role: "assistant",
    content: [
      {
        type: "text",
        text: content,
      },
    ],
  };
}

/**
A message that was generated during the generation process.
It can be either an assistant message or a tool message.
 */
type ResponseMessage = (CoreAssistantMessage | CoreToolMessage) & {
  /**
Message ID generated by the AI SDK.
 */
  id: string;
};

export class MessageHistory {
  private history: CoreMessage[];
  private stateDir: string;
  constructor({ stateDir }: { stateDir: string }) {
    this.history = [];
    this.stateDir = stateDir;
  }

  get() {
    return [...this.history].filter((msg) => {
      // Filter out messages with empty content arrays
      return !Array.isArray(msg.content) || msg.content.length > 0;
    });
  }

  clear() {
    this.history.length = 0;
  }

  appendUserMessage(msg: string): void;
  appendUserMessage(msg: CoreUserMessage): void;
  appendUserMessage(msg: string | CoreUserMessage) {
    const msgObj = isString(msg) ? createUserMessage(msg) : msg;
    this.history.push(msgObj);
  }

  appendAssistantMessage(msg: string): void;
  appendAssistantMessage(msg: CoreAssistantMessage): void;
  appendAssistantMessage(msg: string | CoreAssistantMessage) {
    const msgObj = isString(msg) ? createAssistantMessage(msg) : msg;
    this.history.push(msgObj);
  }

  appendResponseMessages(responseMessages: ResponseMessage[]) {
    // Filter out messages with empty content arrays
    const validMessages = responseMessages.filter((msg) => {
      return !Array.isArray(msg.content) || msg.content.length > 0;
    });
    this.history.push(...validMessages);
  }

  isEmpty() {
    return this.history.length === 0;
  }

  async save() {
    await mkdir(this.stateDir, { recursive: true });
    const timestamp = new Date().toISOString().replace(/:/g, "-");
    const fileName = `message-history-${timestamp}.json`;
    const filePath = join(this.stateDir, fileName);

    await writeFile(filePath, JSON.stringify(this.history, null, 2));
  }

  async summarizeAndReset({ langModel }: { langModel: LanguageModel }) {
    // save existing message history
    await this.save();
    // summarize message history
    this.appendUserMessage(
      createUserMessage(
        "Provide a detailed but concise summary of our conversation above. Focus on information that would be helpful for continuing the conversation, including what we did, what we're doing, which files we're working on, and what we're going to do next.",
      ),
    );
    const { text, usage } = await generateText({
      model: langModel,
      system:
        "You are a helpful AI assistant tasked with summarizing conversations.",
      messages: this.get(),
    });
    //clear messages
    this.clear();
    // reset messages with the summary
    this.appendAssistantMessage(createAssistantMessage(text));

    return { text, usage };
  }
}

/**
 * Normalizes an array of messages for API consumption by:
 * 1. Filtering out progress-type messages
 * 2. Processing user and assistant messages
 * 3. Handling tool results by either:
 *    - Adding them as new messages if they're the first tool result
 *    - Adding them as new messages if the previous message wasn't a tool result
 *    - Merging them with the previous message if it was also a tool result
 *
 * This consolidation of sequential tool results into a single message
 * ensures proper formatting for API consumption while maintaining the
 * logical flow of the conversation.
 *
 * @param messages - Array of messages to normalize
 * @returns Normalized array of user and assistant messages ready for API
 */
export function normalizeMessagesForApi(
  messages: CoreMessage[],
): CoreMessage[] {
  const result: CoreMessage[] = [];
  for (const message of messages) {
    switch (message.role) {
      case "user": {
        result.push(message);
        continue;
      }
      case "tool": {
        // If the last message is not a tool result, add it to the result
        const lastMessage = result.at(-1);
        if (
          !lastMessage ||
          lastMessage.role === "assistant" ||
          !Array.isArray(lastMessage.content) ||
          lastMessage.content[0]?.type !== "tool-result"
        ) {
          result.push(message);
          continue;
        }

        // Otherwise, merge the current message with the last message
        result[result.indexOf(lastMessage)] = {
          ...lastMessage,
          content: [...lastMessage.content, ...message.content] as any,
        };
        continue;
      }
      case "assistant": {
        result.push(message);
        continue;
      }
      default:
        continue;
    }
  }
  return result;
}
